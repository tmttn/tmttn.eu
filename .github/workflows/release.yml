name: Release & Changelog

on:
  workflow_run:
    workflows: ["Deploy to Production"]
    types:
      - completed
    branches: [main]
  workflow_dispatch:

jobs:
  release:
    name: Create Release & Generate Changelog
    runs-on: ubuntu-latest
    
    # Only run if Deploy to Production workflow succeeded and deployed changes
    if: github.event.workflow_run.conclusion == 'success'
    
    permissions:
      contents: write
      pull-requests: read
    
    steps:
    - name: Check if deployment actually occurred
      id: deployment-check
      run: |
        # Check if the Deploy to Production workflow actually deployed changes
        # by looking for the deployment summary in the workflow run
        
        WORKFLOW_RUN_ID="${{ github.event.workflow_run.id }}"
        echo "ðŸ” Checking if deployment workflow $WORKFLOW_RUN_ID actually deployed changes..."
        
        # Get the workflow run jobs and check for deployment summary
        JOBS_OUTPUT=$(gh api /repos/${{ github.repository }}/actions/runs/$WORKFLOW_RUN_ID/jobs --jq '.jobs[].steps[] | select(.name == "Create deployment summary (deployed)") | .conclusion')
        
        if [ "$JOBS_OUTPUT" = "success" ]; then
          echo "âœ… Deployment occurred - release should be created"
          echo "deployment_occurred=true" >> $GITHUB_OUTPUT
        else
          echo "â­ï¸ No deployment occurred - skipping release"
          echo "deployment_occurred=false" >> $GITHUB_OUTPUT
        fi
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Checkout production branch
      if: steps.deployment-check.outputs.deployment_occurred == 'true'
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Need full history for changelog generation
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Setup Node.js
      if: steps.deployment-check.outputs.deployment_occurred == 'true'
      uses: actions/setup-node@v4
      with:
        node-version: '22.x'
        cache: 'npm'
    
    - name: Install dependencies
      if: steps.deployment-check.outputs.deployment_occurred == 'true'
      run: npm ci --frozen-lockfile
    
    - name: Get current package version
      if: steps.deployment-check.outputs.deployment_occurred == 'true'
      id: current-version
      run: |
        VERSION=$(node -p "require('./package.json').version")
        echo "current-version=$VERSION" >> $GITHUB_OUTPUT
        echo "Current package.json version: $VERSION"
    
    - name: Generate Changelog from Conventional Commits
      id: changelog
      if: steps.deployment-check.outputs.deployment_occurred == 'true'
      uses: TriPSs/conventional-changelog-action@v6
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        output-file: 'CHANGELOG.md'
        version-file: 'package.json'
        version-path: 'version'
        create-summary: 'true'
        skip-on-empty: 'false'
        skip-version-file: 'false'
        skip-commit: 'false'
        git-message: 'ðŸ“ docs: update CHANGELOG.md for v{version} [skip ci]'
        git-user-name: 'github-actions[bot]'
        git-user-email: 'github-actions[bot]@users.noreply.github.com'
        preset: 'conventionalcommits'
        config-file-path: '.versionrc.json'
        fallback-version: 'patch'
        skip-tag: 'true'
        skip-ci: 'false'
        
    - name: Get new package version after changelog
      if: steps.deployment-check.outputs.deployment_occurred == 'true'
      id: new-version
      run: |
        NEW_VERSION=$(node -p "require('./package.json').version")
        echo "new-version=$NEW_VERSION" >> $GITHUB_OUTPUT
        echo "New package.json version after changelog: $NEW_VERSION"
    
    - name: Check if release already exists for new version
      if: steps.deployment-check.outputs.deployment_occurred == 'true'
      id: check-release
      run: |
        if gh release view "v${{ steps.new-version.outputs.new-version }}" >/dev/null 2>&1; then
          echo "exists=true" >> $GITHUB_OUTPUT
          echo "Release v${{ steps.new-version.outputs.new-version }} already exists"
        else
          echo "exists=false" >> $GITHUB_OUTPUT
          echo "Release v${{ steps.new-version.outputs.new-version }} does not exist - will create"
        fi
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Validate version after changelog generation
      id: validate-version
      if: steps.deployment-check.outputs.deployment_occurred == 'true' && steps.check-release.outputs.exists == 'false'
      run: |
        NEW_VERSION="${{ steps.new-version.outputs.new-version }}"
        echo "Generated version: $NEW_VERSION"
        
        if [ "$NEW_VERSION" = "null" ] || [ -z "$NEW_VERSION" ]; then
          echo "âŒ Invalid version generated: $NEW_VERSION"
          echo "Falling back to patch bump from ${{ steps.current-version.outputs.current-version }}"
          
          # Parse current version and increment patch
          CURRENT_VERSION="${{ steps.current-version.outputs.current-version }}"
          if [[ $CURRENT_VERSION =~ ^([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
            MAJOR=${BASH_REMATCH[1]}
            MINOR=${BASH_REMATCH[2]}
            PATCH=${BASH_REMATCH[3]}
            PATCH=$((PATCH + 1))
            FALLBACK_VERSION="$MAJOR.$MINOR.$PATCH"
          else
            FALLBACK_VERSION="0.2.1"
          fi
          
          echo "Setting version to: $FALLBACK_VERSION"
          npm version $FALLBACK_VERSION --no-git-tag-version
          
          # Update changelog header to use correct version
          sed -i "1s/.*/## $FALLBACK_VERSION ($(date +%Y-%m-%d))/" CHANGELOG.md
          
          echo "version=$FALLBACK_VERSION" >> $GITHUB_OUTPUT
        else
          echo "âœ… Valid version generated: $NEW_VERSION"
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
        fi
        
    - name: Enhance CHANGELOG.md with summaries and structure
      if: steps.deployment-check.outputs.deployment_occurred == 'true' && steps.check-release.outputs.exists == 'false'
      run: |
        echo "âœ¨ Enhancing CHANGELOG.md with intelligent summaries..."
        
        # Get the version for processing
        VERSION=$(node -p "require('./package.json').version")
        
        # Create enhanced changelog with summary
        node -e "
        const fs = require('fs');
        const changelog = fs.readFileSync('CHANGELOG.md', 'utf8');
        
        // Extract the first version section
        const lines = changelog.split('\n');
        let versionStart = -1;
        let versionEnd = lines.length;
        
        for (let i = 0; i < lines.length; i++) {
          if (lines[i].startsWith('## ')) {
            if (versionStart === -1) {
              versionStart = i;
            } else {
              versionEnd = i;
              break;
            }
          }
        }
        
        if (versionStart === -1) process.exit(0);
        
        const versionSection = lines.slice(versionStart, versionEnd);
        const commits = versionSection.filter(line => line.startsWith('* '));
        
        // Analyze commits for summary generation
        const features = commits.filter(line => line.includes('âœ¨') || line.includes('feat:')).length;
        const fixes = commits.filter(line => line.includes('ðŸ›') || line.includes('fix:')).length;
        const perf = commits.filter(line => line.includes('âš¡') || line.includes('perf:')).length;
        const security = commits.filter(line => line.includes('ðŸ”’') || line.includes('security:')).length;
        const tests = commits.filter(line => line.includes('ðŸ§ª') || line.includes('test:')).length;
        const total = commits.length;
        
        // Generate intelligent summary
        let summary = '';
        if (features >= 5) {
          summary = '**Major Release** - Significant new features and functionality improvements.';
        } else if (features >= 2) {
          summary = 'Feature release with new functionality and enhancements.';
        } else if (fixes >= 3) {
          summary = 'Maintenance release focused on bug fixes and stability improvements.';
        } else if (security > 0) {
          summary = 'Security update with vulnerability fixes and improvements.';
        } else if (perf > 0) {
          summary = 'Performance improvements and optimization updates.';
        } else {
          summary = 'Minor updates with dependency changes and maintenance improvements.';
        }
        
        // Add feature highlights
        let highlights = [];
        if (features > 0) highlights.push(\`\${features} new feature\${features > 1 ? 's' : ''}\`);
        if (fixes > 0) highlights.push(\`\${fixes} bug fix\${fixes > 1 ? 'es' : ''}\`);
        if (security > 0) highlights.push(\`\${security} security update\${security > 1 ? 's' : ''}\`);
        if (perf > 0) highlights.push(\`\${perf} performance improvement\${perf > 1 ? 's' : ''}\`);
        
        // Insert summary after version header
        const enhancedSection = [
          versionSection[0], // Version header
          '',
          '### Summary',
          summary,
          ...(highlights.length ? ['', \`This release includes \${highlights.join(', ')}.\`] : []),
          '',
          ...versionSection.slice(1)
        ];
        
        // Reconstruct changelog
        const newChangelog = [
          ...lines.slice(0, versionStart),
          ...enhancedSection,
          ...lines.slice(versionEnd)
        ].join('\n');
        
        fs.writeFileSync('CHANGELOG.md', newChangelog);
        "
        
        echo "ðŸ§¹ Fixing CHANGELOG.md markdown formatting..."
        
        # Ensure file starts with proper header if missing
        if ! grep -q "^# Changelog" CHANGELOG.md; then
          echo "Adding changelog header..."
          sed -i '1i# Changelog\n\nAll notable changes to Thomas Metten'\''s personal portfolio website are documented in this file.\n' CHANGELOG.md
        fi
        
        # Remove excessive blank lines (more than 2 consecutive)
        sed -i '/^$/N;/^\n$/d' CHANGELOG.md
        
        # Ensure single trailing newline
        sed -i -e :a -e '/^\s*$/{$d;N;ba' -e '}' CHANGELOG.md
        echo "" >> CHANGELOG.md
        
        echo "âœ… CHANGELOG.md enhanced with summaries and formatting fixed"
    
    - name: Sync version and CHANGELOG.md to main branch
      if: steps.deployment-check.outputs.deployment_occurred == 'true' && steps.check-release.outputs.exists == 'false'
      run: |
        echo "ðŸ”„ Syncing version bump and CHANGELOG.md back to main branch..."
        
        # Store the updated files
        cp CHANGELOG.md /tmp/updated-changelog.md
        cp package.json /tmp/updated-package.json
        
        # Switch to main branch
        git fetch origin main
        git checkout main
        
        # Copy the updated files
        cp /tmp/updated-changelog.md CHANGELOG.md
        cp /tmp/updated-package.json package.json
        
        # Check if there are actual changes
        if git diff --quiet CHANGELOG.md package.json; then
          echo "No changes to sync"
        else
          echo "Committing version bump and CHANGELOG.md to main branch..."
          git add CHANGELOG.md package.json
          git commit -m "ðŸ“ docs: sync version v${{ steps.validate-version.outputs.version }} and CHANGELOG.md [skip ci]"
          git push origin main
          echo "âœ… Version and CHANGELOG.md synced to main branch"
        fi
    
    - name: Create Release with auto-generated notes
      if: steps.deployment-check.outputs.deployment_occurred == 'true' && steps.check-release.outputs.exists == 'false'
      uses: softprops/action-gh-release@v2
      with:
        tag_name: v${{ steps.validate-version.outputs.version }}
        name: Release v${{ steps.validate-version.outputs.version }}
        body: ${{ steps.changelog.outputs.clean_changelog }}
        target_commitish: production
        make_latest: true
        generate_release_notes: true
        append_body: true
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Release Summary
      if: steps.deployment-check.outputs.deployment_occurred == 'true' && steps.check-release.outputs.exists == 'false'
      run: |
        echo "## ðŸŽ‰ Release Created Successfully" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "- **Version**: v${{ steps.validate-version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Branch**: production" >> $GITHUB_STEP_SUMMARY
        echo "- **Release URL**: https://github.com/${{ github.repository }}/releases/tag/v${{ steps.validate-version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Version & CHANGELOG**: Updated on production branch and synced to main" >> $GITHUB_STEP_SUMMARY
        echo "- **CI Impact**: Changelog sync uses [skip ci] to prevent new pipeline" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "The release includes all changes that were rebased to the production branch." >> $GITHUB_STEP_SUMMARY
    
    - name: Skip Release (Already Exists)
      if: steps.deployment-check.outputs.deployment_occurred == 'true' && steps.check-release.outputs.exists == 'true'
      run: |
        echo "## â„¹ï¸ Release Already Exists" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "- **Version**: v${{ steps.new-version.outputs.new-version }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Status**: Release already exists, skipping creation" >> $GITHUB_STEP_SUMMARY
        echo "- **Release URL**: https://github.com/${{ github.repository }}/releases/tag/v${{ steps.new-version.outputs.new-version }}" >> $GITHUB_STEP_SUMMARY
    
    - name: Skip Release (No Deployment)
      if: steps.deployment-check.outputs.deployment_occurred == 'false'
      run: |
        echo "## â­ï¸ Release Skipped" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "- **Reason**: No user-facing deployment occurred" >> $GITHUB_STEP_SUMMARY
        echo "- **Deploy Workflow**: Only test/docs/CI changes were detected" >> $GITHUB_STEP_SUMMARY
        echo "- **Result**: No release created since no production changes were deployed" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "A release will be created automatically when user-facing changes are deployed to production." >> $GITHUB_STEP_SUMMARY